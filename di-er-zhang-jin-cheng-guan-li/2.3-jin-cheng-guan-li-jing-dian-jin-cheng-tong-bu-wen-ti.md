# 2.3 进程管理（经典进程同步问题）

## 一、生产者消费者问题

* 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用；
* 生产者、消费者共享一个初始为空、大小为n的缓冲区；
* 只有缓冲区**没满**时，生产者才能把产品**放入**缓冲区，否则必须等待；
* 只有缓冲区**不空**时，消费者才能从中**取出**产品，否则必须等待；
* 缓冲区是临界资源，各进程必须**互斥地**访问。

### 1、分析关系

* 生产者和消费者访问缓冲区是**互斥**的；
* 生产者和消费者的工作需要**同步**，即生产完成之后才能消费。

![&#x751F;&#x4EA7;&#x8005;-&#x6D88;&#x8D39;&#x8005;&#x540C;&#x6B65;&#x5173;&#x7CFB;](../.gitbook/assets/sheng-chan-zhe-xiao-fei-zhe-.png)

### 2、设置信号量

```c
semaphore mutex = 1;    //互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;    //同步信号量，表示空闲缓冲区的数量
semaphore full = 0;     //同步信号量，表示产品（非空缓冲区）的数量
```

### 3、实际代码

```c
producer(){
    while(1){
        生产产品
        P(empty);    //申请新的缓冲区
        P(mutex);    //申请访问临界资源
        存入缓冲区
        V(mutex);    //释放临界资源
        V(full);     //释放一个消费品（非空缓冲区）
    }
}

consumer(){
    while(1){
        P(full);     //申请使用消费品
        P(mutex);    //申请访问临界资源
        从缓冲区取出
        V(mutex);    //释放临界资源
        V(empty);    //释放一个空缓冲区
        消费产品
    }
}
```

{% hint style="danger" %}
实现**互斥**的P操作一定要在实现**同步**的P操作**之后**

两个V操作可以交换顺序
{% endhint %}



