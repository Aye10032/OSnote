# 2.4 死锁

## 2.4.1 死锁的概念

### 1、死锁的定义

在并发环境下，各进程因竞争资源而造成的一种**相互等待对方手里的资源**，导致这些进程均阻塞。若没有外力干涉，这些进程都无法继续前进。

{% hint style="warning" %}
**死锁**：互相等待对方手里的资源，导致各进程都阻塞，无法前进的现象

**饥饿**：由于长期得不到资源，某进程一直得不到处理机的现象

**死循环**：某进程执行过程中一直跳不出某个循环的现象
{% endhint %}

### 2、死锁产生的必要条件

死锁的产生，以下四个条件缺一不可：

1. **互斥条件**：只有对互斥资源的争抢才可能导致死锁；
2. **不剥夺条件**：进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放；
3. **请求和保持条件**：进程**已经占用了至少一个资源**，同时又提出了新的资源请求，而所**请求的资源被其他进程所占用**，此时请求被阻塞，但是该进程**仍然保持已有的资源不放**；
4. **循环等待条件**：存在一种进程循环等待资源的现象，循环中的每一个进程已获得的资源同时被下一个进程所需求。

{% hint style="danger" %}
发生死锁时一定有循环等待，但发生循环等待时未必会死锁。

如果系统中还有其他同类型资源，则不会发生死锁；如果系统中每种资源只有一个，则将会发生死锁。
{% endhint %}

综上，可以有以下结论：

#### 1、死锁产生的原因

1. 系统资源的竞争
2. 进程推进顺序非法

#### 2、死锁的处理策略

1. 死锁预防
2. 避免死锁
3. 死锁的检测及解除

## 2.4.2 死锁预防

预防死锁的发生只需要**破坏四个必要条件之一**即可。

### 1、破坏互斥条件

把只能互斥访问的资源变为共享资源。例如使用SPOOLing技术使得设备可以逻辑上共享。但是一般不常用。

### 2、破坏不剥夺条件

一、当某个进程请求新的资源而得不到时，立刻释放其已有资源，以待后面再次申请；

二、为进程设置不同的优先级，当某个进程需要的资源被其他进程占用时，可以由操作系统协作将想要的资源强行剥夺。

#### 缺点：

* 实现起来较为复杂；
* 这种方式会造成前一阶段工作的失效，因此仅适用于易保存和恢复的资源，例如CPU；
* 反复申请和释放资源会造成较大的系统开销；
* 若采用方案一，可能导致饥饿（某个进程一直被迫放弃已有的资源）。

### 3、破坏请求和保持条件

采用**静态分配方法**，在运行前一次性申请所需的全部资源，在未获得全部资源前进程不投入运行。一旦投入运行，这些资源一直归此进程所有。

#### 缺点：

* 对于使用时间很短的资源会造成资源浪费，资源利用率低；
* 有可能导致某些进程饥饿。

### 4、破坏循环等待条件

采用**顺序资源分配法**，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。

#### 缺点：

* 不方便增加新的系统资源，有可能需要全部重新分配序号；
* 进程实际使用资源的顺序可能与序号不一致，会造成资源浪费；
* 必须依次申请资源，编程麻烦。

## 2.4.3 死锁避免

### 1、安全序列、不安全状态、死锁的联系

**安全序列**：如果系统按照这种序列分配资源，则每个进程都能顺利完成。

**安全状态**：只要能找出一个安全序列，系统就是安全状态。安全序列可能有多个。

**不安全状态**：如果分配了资源之后，系统中**找不出任何一个安全序列**，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。

如果有进程**提前归还**了一些资源，系统也有可能重新回到**安全状态**。

#### 与死锁的联系

* 系统如果处于安全状态，则一定不会发生死锁；
* 系统如果处于不安全状态，则可能会发生死锁；
* 因此，可以通过提前判断是否会进入不安全状态来决定是否答应分配请求。

### 2、银行家算法

假设系统中有n个进程，m种资源。

每个进程在运行前事先声明对各个资源的最大需求数，则可用一个n\*m的矩阵表示所有进程对各种资源的最大需求数，称为**最大需求矩阵Max**，Max\[i, j\]=K 表示进程Pi最多需要K个资源Rj。

同理，系统可以用一个n\*m的**分配矩阵Allocation**表示对所有进程的资源分配情况。Max - Allocation = **Need矩阵**，表示各进程还需要多少资源。





